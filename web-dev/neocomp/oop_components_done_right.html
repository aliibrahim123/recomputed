<!DOCTYPE html>
<head>
	<title>ReComputed: The Power Of OOP Components, Done Right</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" class="preserve-on-route" href="../../styles/app.css">
	<script type="module" src="../../src/base.ts"></script>
	<script type="module" src='../../src/article.ts'></script>
	<link rel="stylesheet" class="preserve-on-route" href="../../styles/syntax-highlight.css">
</head>
<body>
  <div id="root" comp-name="@lazy:article" style="display: none" root-href="../../" highlight walk>
	<div id="info">
		<span prop="title">The Power Of OOP Components, Done Right</span>
		<span prop="created">4-8-2025</span>
	</div>
	<h1>The Limitations of Functional Components</h1>
	<p>Functional declarative components are one of the greatest milestones in the evolution of UI development. They transitioned us from the over-engineered MVC architecture and manual DOM updates to the declarative, reactive components we know and love. However, they have their limitations.</p>
	<p>The declarative nature of today's frameworks simplified DOM construction and updates, but at the same time, it took away DOM ownership and restricted our ability to manipulate the DOM under its control.</p>
	<p>The unpredictable nature of framework internals, a consequence of declarativity, while being localized by fine-grained reactivity to specific elements, has constrained the ability to manipulate the DOM manually. At best, such manual changes will be overwritten.</p> 
	<p>Furthermore, because components are functions that return the structure, this approach prohibits starting from existing DOM elements and complicates the manipulation of the component's DOM after removal.</p>
	<p>In addition, functions don't scale. The factory paradigm is designed for small, simple components with minimal state and reactivity, not for complex, large components that encapsulate complicated logic and enormous state.</p>
	<p>Moreover, the abstracted nature of functional components limits their ability to interact with the outside world, forcing their declaration inside the component since they are not normal values, which increases logic complexity within components.</p>
	<p>When you call them, they return the structure, not the component itself. Our components have lost their identity.</p>

	<h1>The OOP Components Were Not Bad</h1>
	<p>Object-oriented components, like any OOP technology, are not inherently bad. The culture and traditions associated with them are what made them feel that way. The issue with past frameworks was their focus on complex MVC patterns, not on the UI itself, and this was a problem of architecture, not of the object-oriented paradigm.</p>
	<p>The real problem was the separation of data from the UI. What are the real benefits of separating concerns through countless classical MVx patterns when the data is already processed by the server? It just created countless useless concepts that should not have been used.</p>
	<p>Moreover, these frameworks provided little, if any, templating. At a minimum, you would use jQuery for manual DOM manipulation or use a templating engine that provided minimal bindings, in contrast to the deep reactivity and expressive templating we have today.</p>
	<p>In short, the issue was the focus on the complicated design patterns associated with classical OOP culture and the lack of declarative reactivity, which is not a problem with the OOP component itself. However, functional programming won because of its minimal nature at a time when we were tired of everything related to classical OOP.</p>
	<p>And, as a surprising fact, the old view units were actually a render function wrapped in a class, a pattern that persisted in React with its class-based components before the evolution of hooks.</p>
	<p>Contrary to what one might think, declarative reactivity is not limited to the functional paradigm. While a function's declarative nature makes it a good choice, it is a concept that can be adopted even in imperative programming, and it is absolutely able to thrive in OOP components.</p>
	<details @chunk:closable-code="(
		{title: 'Declarative Reactivity in Imperative Programming Example', lang: 'javascript', el}
	)"><!--
		const display = createElement('div');
		addChild(display, createTextNode('count: '));
		const countText = createTextNode('0');
		bindText(countText, () => get('count'), ['count']);
		addChild(display, countText);
		addChild(root, display);
		const button = createElement('button');
		addListener(button, 'click', () => set('count', get('count') + 1));
		addChild(button, 'increment');
		addChild(root, button);
	--></details>

	<h1>About NeoComp Components</h1>
	<p>NeoComp is a concept framework that fuses declarative reactivity with object-oriented components, combining the simplicity of reactivity with the flexible power of OOP components, thereby creating flexible components for all use cases.</p>
	<p>NeoComp components are ordinary object-oriented components that encapsulate their own logic and state. They feature declarative reactivity in their APIs, wrapping an element and binding via their states to the DOM through fine-grained reactivity.</p>
	<p>Events call methods on the component, which then update the states that are bound to the DOM through bindings declared in templates.</p>
	<pre><code class='language-javascript'><!--
		class Counter extends Component {
			static template = $template(`
				<div .text>count: @{count}></div>
				<button @on(click)='comp.count.value++'>increment</button>
			`);
			count = this.signal('count', 0);
			contructor(el) {
				super(el, 'full');
				this.effect('track', () => console.log('count: ', this.count.value));
			}
		}
	--></code></pre>
	<p>The NeoComp approach tries to bridge the gap between these two worlds, offering simple yet powerful fine-grained reactivity while still having the organizational benefits of object-oriented components. This approach has had some very surprising outcomes.</p>

	<h1>The Surprising Advantages of OOP Components</h1>
	<h2>Better Organization</h2>
	<p>One of the notable benefits of OOP is its inherent, organizable structure. In contrast to a functional component where a single function can quickly grow out of hand, you can split complex logic into multiple methods and interact with each other via shared state in fields. This makes object-oriented components a better choice for large, stateful components with complex logic.</p>
	<pre><code class='language-javascript'><!--
		function counter (props) {
			function someLogic1() {}
			function someLogic2() {}
			function someLogic3() {}
			//...
			return <> ... </>
		}

		// vs
		class Counter extends Component {
			static template = ....;
			contructor () {}
			someLogic1() {}
			someLogic2() {}
			someLogic3() {}
		}
	--></code></pre>

	<h2>First-Class Citizen Components</h2>
	<p>A key outcome of switching to OOP is that components become first-class citizens. Components in OOP have a tangible, accessible value, in contrast to the abstract nature of functional components. This completely simplifies interaction with the outside world and opens many new possibilities.</p>
	<p>Interactions can happen from outside the component, not only from within, which reduces some logic complexity inside the components.</p>
	<p>Components can also officially expose a public interface in a non-hacky way, allowing other components to interact with them, in contrast to functional components that are typically passed events as arguments and that's it.</p>
	<pre><code class='language-javascript'><!--
		class Counter extends Component {
			#privateLogic () {}
			#privateState = this.signal('some-state');

			publicLogic () {}
			publicState = this.#privateState.asReadOnly;
		}
		
		// ...
		comp.publicLogic();
	--></code></pre>

	<h2>Full Ownership of the DOM</h2>
	<p>NeoComp's goal is to give you, the developer, full control and ownership of the DOM. The components are designed to wrap elements and create new ones if not provided. This enables the wrapping of existing elements with their structures, not just children constructed at creation, which allows for more design patterns.</p>
	<p>These components can also leave their elements after removal if requested, in contrast to functional components that always destroy them, allowing for removal animations and changing the components around an element.</p>
	<p>NeoComp favors direct DOM manipulation when needed and provides utilities for simplifying the process, as well as countless utilities for avoiding the need for them.</p>
	<p>And most crucially, NeoComp provides you with true ownership of the DOM. Its actions on the DOM are localized to specific elements and attributes defined in the template. You can safely interact with other elements. Moreover, because of the direct nature of the DOM bindings, you can move target elements around, even outside the component, or remove and restore them later while preserving the bindings.</p>
	<pre><code class='language-javascript'><!--
		static template = $template(`...<div @ref="display" .text>count: @{count}</div>...`);

		// ...
		someForignElement.append(comp.refs.display);
		comp.el.append(someForignElement);
	--></code></pre>

	<h2>Simplified Internals</h2>
	<p>Having an accessible value for components simplifies the internals a lot. Primarily, it removes the need for magic functions that work on the underlying internal component structures and have their constraints (which are the only solution for functional components).</p>
	<p>In addition, it also simplifies template internals. Instead of having algorithms that detect the used states and functions in directives, the component's value can be passed instead, removing the need for these algorithms.</p>
	<pre><code class='language-javascript'><!--
		const state = signal(0);
		const state = this.signal(0);
	--></code></pre>
	<pre><code class='language-html'><!--
		<button @on(click)='increament()'>increament</button>
		<button @on(click)='comp.increament()'>increament</button>
	--></code></pre>

	<h2>Unmatched Flexibility</h2>
	<p>NeoComp's primary goal is to be a flexible framework adaptable to all use cases. It achieves this by making its units very flexible and unrestrictive, giving the developer complete freedom.</p>
	<p>NeoComp provides a robust toolset, supporting lazy loading, first-class asynchronous programming, fine-grained reactivity, independent context for state management, auto dependency management, and much more.</p>
	<p>Components in NeoComp are anonymous by default. They are not fixed in a static hierarchy; they behave more like DOM nodes than components in other frameworks. You can move them around in the main hierarchy or between different ones, and remove them, then restore them later.</p>
	<p>NeoComp exposes a broader API surface, and its internal mechanisms are dynamic. The definitions (state, effects, contexts, etc.) can be created and modified at any time, in any place, not only at initialization.</p>
	<p>You can even have the logic directly in the DOM for small, hacky projects.</p>
	<pre><code class='language-javascript'><!--
		new Component(someEl, 'full');
	--></code></pre>
	<pre><code class='language-html'><!--
		<div id=some-el>
			<div .text>count: @{count}</div>
			<button @on(click)='comp.set('count', comp.get('count') + 1)'>increment</button>
		</div>
	--></code></pre>

	<h1>The Ending, But Not The End</h1>
	<p>In summary, NeoComp is a frontend framework that combines the simplicity and efficiency of fine-grained reactivity with the organizational power of object-oriented components. It is also flexible enough in design to power everything from the smallest components to the largest ones.</p>
	<p>It is a case study showing that simplicity in directness outperforms simplicity in declarativeness. Simplicity is not in the API surface; it is in the implementation.</p>
	<p>React showed the world the power of declarative, reactive UI, but it had its limitations. The rest of the world further enhanced it through optimization and refinement, to the point where we made it as efficient as manual DOM manipulation through fine-grained reactivity.</p>
	<p>However, there were still issues with our approaches. The function paradigm is for the factory pattern—one-shot creation—not for components with a lifecycle, and absolutely not for components with complex behaviors. Declarativity is not meant only for functions; it can be integrated with OOP, the paradigm designed primarily for stateful entities.</p>
	<p>Finally, the quest doesn't stop here. There remain patterns in the wild that are yet to be discovered. Furthermore, we have the milestone of moving React into the efficient reactivity paradigms, and with it, the vast majority of the modern web.</p>
	<p>If you are interested in NeoComp's concepts and want to learn more about it and its inner workings, check its documentation and dive into its source code on its <a -href='webdiv.neocomp'>repo</a> on GitHub, and don't forget it is just a concept.</p>
  </div>
</body>